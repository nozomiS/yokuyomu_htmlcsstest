<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>行数ベース縦書きページ分割</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@400&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded" />
    <style>
        /* 上部バー */
        #top-bar {
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 54px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #fafafa;
            box-shadow: 0 2px 8px rgba(0,0,0,0.10);
            z-index: 1001;
            padding: 0 16px;
            transition: transform 0.2s;
        }
        #top-bar.hidden {
            transform: translateY(-100%);
            pointer-events: none;
            opacity: 0;
        }
        #top-bar .material-symbols-outlined, #top-bar .material-symbols-rounded {
            font-size: 2em;
            cursor: pointer;
            user-select: none;
        }
        #top-bar-title {
            flex: 1 1 auto;
            text-align: center;
            font-size: 1.1em;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin: 0 16px;
        }
    .material-symbols-outlined {
      font-variation-settings:
      'FILL' 0,
      'wght' 400,
      'GRAD' 0,
      'opsz' 24
    }
    </style>
    <style>
        html, body {
            margin: 0; padding: 0; height: 100%; width: 100%;
            font-family: 'Noto Sans JP', 'Yu Gothic', 'Meiryo', sans-serif; font-size: 16px; line-height: 1.8;
            font-feature-settings: "lnum" 1, "pnum" 1;
            letter-spacing: 0.05em; color: #333; display: flex;
        }

        /* 本文（縦書きページ）を源ノ明朝で */
        .page, .page .content, .page p, .page h3 {
            font-family: 'Source Han Serif JP', 'Noto Serif JP', 'Yu Mincho', 'Hiragino Mincho ProN', 'MS PMincho', serif;
        }
        /* h2見出しはゴシック体で強調 */
        .page h2 {
            font-family: 'Noto Sans JP', 'Yu Gothic', 'Meiryo', sans-serif !important;
            font-weight: bold;
            font-size: 1.7em;
            letter-spacing: 0.08em;
        }

        /* Google Fonts: 源ノ明朝（Source Han Serif JP）を読み込み */
        @import url('https://fonts.googleapis.com/css2?family=Source+Han+Serif+JP:wght@400;700&display=swap');
        
        /* --- 昼モード（デフォルト） --- */
        body,
        #viewer,
        .page,
        #book,
        .control-bar,
        #bottom-bar {
            background: #f5ede3;
            color: #3a3632;
        }
        .material-btn {
            background: #ede5d7;
            color: #3a3632;
        }
        #debug-panel {
            background: #f5f5f5;
            color: #333;
        }

        /* --- 夜モード --- */
        body.night-mode,
        body.night-mode #viewer,
        body.night-mode .page,
        body.night-mode #book,
        body.night-mode .control-bar,
        body.night-mode #bottom-bar {
            background: #444542;
            color: #e7e5e1;
        }
        body.night-mode .material-btn {
            background: #575753;
            color: #e7e5e1;
        }
        body.night-mode #debug-panel {
            background: #333;
            color: #e7e5e1;
        }
        
        #debug-panel {
            width: 300px; height: 100vh; overflow-y: auto;
            background-color: #f5f5f5; border-right: 2px solid #ccc;
            padding: 10px;
        }
        
        #debug-info {
            background: white; border: 1px solid #ddd; border-radius: 5px;
            padding: 8px; margin-bottom: 10px; font-family: monospace; font-size: 11px;
        }
        
        #step-controls button {
            margin-right: 5px; padding: 6px 10px;
            border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 11px;
        }
        
        #debug-log {
            background: white; border: 1px solid #ddd; border-radius: 5px;
            padding: 8px; height: 250px; overflow-y: auto; font-family: monospace; font-size: 10px;
        }
        
        #copy-log-btn {
            margin-top: 5px; padding: 4px 8px;
            border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 10px;
            background: #fff;
        }
        
        #viewer-container {
            flex: 1; display: flex; flex-direction: column;
            justify-content: center; align-items: center; padding: 20px;
        }
        
        #viewer {
            width: 70vw; height: 70vh; max-width: 500px;
            border: 1px solid #ccc;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1); position: relative; overflow: hidden;
        }
        #bottom-bar, .control-bar {
            position: absolute; /* ★fixed→absoluteに変更 */
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #fafafa;
            box-shadow: 0 -2px 8px rgba(0,0,0,0.18);
            padding: 10px 0;
            z-index: 1000;
            transition: transform 0.2s;
        }
        #book { 
            height: 100%; width: 100%; position: relative; 
        }
        
        .page {
            height: 100%; width: 100%; position: absolute; top: 0; left: 0;
            padding: 30px 20px; box-sizing: border-box;
            writing-mode: vertical-rl; text-orientation: mixed;
            overflow: hidden;
            visibility: hidden;
        }
        
        .page.visible {
            visibility: visible;
        }
        
        .content {
            width: auto; height: 100%; padding: 0;
            writing-mode: vertical-rl; text-orientation: mixed;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .page p { margin: 0; text-indent: 1em; }
        .page h2 {
            margin: 0; text-indent: 0;
            text-align: center; font-size: 1.5em; font-weight: bold;
        }
        .page h3 { margin: 0; text-indent: 0; }
        .page .no-indent-p { text-indent: 0; }
        
        #measure {
            position: absolute; top: -9999px; left: -9999px; visibility: hidden;
            font-family: 'Noto Sans JP', 'Yu Gothic', 'Meiryo', sans-serif; writing-mode: vertical-rl;
            text-orientation: mixed;
            font-feature-settings: "lnum" 1, "pnum" 1;
        }

        hr.section-separator {
            border: none;
            border-left: 2px solid #aaa;
            height: 80%;
            width: 0;
            margin: 0 16px;
            display: block;
            align-self: center;
        }

        /* 下部コントロールバー */
        .control-bar {
            position: fixed;
            left: 0; right: 0; bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #fff;
            box-shadow: 0 -2px 8px rgba(0,0,0,0.08);
            padding: 10px 0;
            z-index: 1000;
            transition: transform 0.2s;
        }
        .control-bar.hidden {
            transform: translateY(100%);
            pointer-events: none;
            opacity: 0;
        }
        .material-btn {
            background: #f5f5f5;
            border: none;
            border-radius: 50%;
            margin: 0 12px;
            width: 48px; height: 48px;
            font-size: 1.3em;
            color: #333;
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
            transition: 0.2s;
        }
        .material-btn:active {
            background: #e0e0e0;
        }

        .hidden {
            display: none;
        }

    </style>
</head>
<body>

    <div id="viewer-container">
        <div id="viewer">
            <div id="top-bar" class="hidden">
                <span id="topbar-menu" class="material-symbols-outlined" title="メニュー">menu</span>
                <span id="top-bar-title">タイトル</span>
                <span id="topbar-browser" class="material-symbols-outlined" title="ブラウザで開く">open_in_browser</span>
            </div>
            <div id="book"></div>
            <div id="bottom-bar" class="control-bar hidden">
                <button id="font-smaller" class="material-btn" title="文字サイズを小さく">
                  <span class="material-symbols-outlined">text_decrease</span>
                </button>
                <button id="font-bigger" class="material-btn" title="文字サイズを大きく">
                  <span class="material-symbols-outlined" style="font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;">text_increase</span>
                </button>
                <button id="toggle-night" class="material-btn" title="ナイトモード切替">
                  <span class="material-symbols-outlined">nights_stay</span>
                </button>
                <span id="page-indicator" style="margin-left:16px; font-size:1em;">
                    <span id="current-page-indicator">1</span> / <span id="total-page-indicator">1</span>
                </span>
            </div>
        </div>
    </div>
    <div id="source-content" style="display: none;">
    </div>

    <div id="debug-panel">
        <h3>デバッグ情報</h3>
        <div id="debug-info">
            <div>最大行数: <span id="max-lines">-</span>行</div>
            <div>現在行数: <span id="current-lines">-</span>行</div>
            <div>現在ページ: <span id="current-page">1</span> / <span id="total-pages">1</div>
            <div>処理中: <span id="current-element">-</span></div>
            <div>ページID範囲: <span id="page-id-range">-</span></div>
        </div>
        
        <div id="step-controls">E
            <button id="step-btn">1ステップ実行</button>
            <button id="reset-btn">リセット</button>
            <button id="prev-page-btn">◀ 前ページ</button>
            <button id="next-page-btn">次ページ ▶</button>
        </div>
        
        <!-- ▼ここから追加 -->
        <div style="margin:10px 0;">
            <input type="file" id="fileInput" accept=".html">
            <input type="text" id="selectorInput" placeholder="例: .js-novel-text" style="width:120px;">
            <button id="loadHtmlBtn">外部HTML読込</button>
        </div>
        <!-- ▲ここまで追加 -->

        <div id="debug-log"></div>
        <button id="copy-log-btn">ログをコピー</button>
    </div>

    <!-- viewer-container/viewer/top-bar/book/bottom-bar are now grouped together above -->

    <script>
// 半角英数字を全角に変換する関数
function toZenkaku(str) {
    return str.replace(/[A-Za-z0-9]/g, function(s) {
        return String.fromCharCode(s.charCodeAt(0) + 0xFEE0);
    });
}

/**
 * DebugManager - デバッグ情報の管理とログ出力を担当
 */
class DebugManager {
    constructor() {
        this.debugLog = document.getElementById('debug-log');
        this.maxLinesSpan = document.getElementById('max-lines');
        this.currentLinesSpan = document.getElementById('current-lines');
        this.currentElementSpan = document.getElementById('current-element');
        this.currentPageSpan = document.getElementById('current-page');
        this.totalPagesSpan = document.getElementById('total-pages');
        this.pageIdRangeSpan = document.getElementById('page-id-range');
    }

    /**
     * ログメッセージを出力
     */
    log(message) {
        const entry = document.createElement('div');
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        this.debugLog.appendChild(entry);
        this.debugLog.scrollTop = this.debugLog.scrollHeight;
    }

    /**
     * 最大行数を更新
     */
    updateMaxLines(maxLines) {
        if (this.maxLinesSpan) {
            this.maxLinesSpan.textContent = maxLines;
        }
    }

    /**
     * 現在行数を更新
     */
    updateCurrentLines(currentLines) {
        if (this.currentLinesSpan) {
            this.currentLinesSpan.textContent = currentLines;
        }
    }

    /**
     * 現在ページを更新
     */
    updateCurrentPage(currentPage) {
        if (this.currentPageSpan) {
            this.currentPageSpan.textContent = currentPage;
        }
    }

    /**
     * 総ページ数を更新
     */
    updateTotalPages(totalPages) {
        if (this.totalPagesSpan) {
            this.totalPagesSpan.textContent = totalPages;
        }
    }

    /**
     * ページID範囲を更新
     */
    updatePageIdRange(startId, endId) {
        if (this.pageIdRangeSpan) {
            const idRange = startId && endId ? 
                `${startId} - ${endId}` : 
                (startId || endId || '-');
            this.pageIdRangeSpan.textContent = idRange;
        }
    }

    /**
     * 現在の処理要素を更新
     */
    updateCurrentElement(element) {
        if (this.currentElementSpan) {
            this.currentElementSpan.textContent = element;
        }
    }

    /**
     * ページを追加した際のUI更新
     */
    onPageAdded(pageNumber, totalPages, startId = '', endId = '') {
        this.updateTotalPages(totalPages);
        this.log(`ページ${pageNumber}を作成しました (ID: ${startId} - ${endId})`);
        
        // ボトムバーのトータルページも更新
        const totalPageIndicator = document.getElementById('total-page-indicator');
        if (totalPageIndicator) {
            totalPageIndicator.textContent = totalPages.toString();
        }
    }

    /**
     * 現在ページ表示時のUI更新
     */
    onPageDisplayed(currentPage, totalPages, pageInfo = null) {
        this.updateCurrentPage(currentPage);
        
        // ボトムバーの現在ページも更新
        const currentPageIndicator = document.getElementById('current-page-indicator');
        if (currentPageIndicator) {
            currentPageIndicator.textContent = currentPage.toString();
        }
        
        const totalPageIndicator = document.getElementById('total-page-indicator');
        if (totalPageIndicator) {
            totalPageIndicator.textContent = totalPages.toString();
        }
        
        // ページID範囲を表示
        if (pageInfo) {
            this.updatePageIdRange(pageInfo.startId, pageInfo.endId);
        }
    }

    /**
     * ページがない場合のUI更新
     */
    onNoPages() {
        this.log('ページがありません');
        // ページインジケータもリセット
        const currentPageIndicator = document.getElementById('current-page-indicator');
        const totalPageIndicator = document.getElementById('total-page-indicator');
        if (currentPageIndicator) currentPageIndicator.textContent = '0';
        if (totalPageIndicator) totalPageIndicator.textContent = '0';
        this.updatePageIdRange('', '');
    }

    /**
     * ログをクリップボードにコピー
     */
    copyLog() {
        const logText = Array.from(this.debugLog.children)
            .map(entry => entry.textContent)
            .join('\n');
        
        navigator.clipboard.writeText(logText).then(() => {
            this.log('ログをクリップボードにコピーしました');
        }).catch(err => {
            this.log('コピーに失敗しました: ' + err);
        });
    }

    /**
     * ログをクリア
     */
    clearLog() {
        this.debugLog.innerHTML = '';
    }

    /**
     * デバッグUI全体の初期化
     */
    setupDebugUI() {
        this.log('デバッグUI初期化完了');
    }
}

/**
 * PageManager - ページデータの管理を担当（制御ロジックは含まない）
 */
class PageManager {
    constructor() {
        this.pages = []; // 各ページのHTML内容
        this.pageInfos = []; // 各ページのID情報（開始ID、終了ID）
    }

    /**
     * ページを追加（重複チェック付き）
     */
    addPage(content, startId = '', endId = '') {
        // 重複チェック：最後のページと同じ内容なら追加しない
        if (this.pages.length > 0 && this.pages[this.pages.length - 1] === content) {
            return false; // 追加されなかった
        }
        
        return forceAddPage(content, startId, endId);
    }

    /**
     * ページを強制追加（重複チェックなし）
     */
    forceAddPage(content, startId = '', endId = '') {
        this.pages.push(content);
        this.pageInfos.push({ startId, endId });
        return true;
    }

    /**
     * 総ページ数を取得
     */
    getPageCount() {
        return this.pages.length;
    }

    /**
     * 指定したページのコンテンツを取得
     */
    getPageContent(pageIndex) {
        if (pageIndex >= 0 && pageIndex < this.pages.length) {
            return this.pages[pageIndex];
        }
        return null;
    }

    /**
     * 指定したページの情報を取得
     */
    getPageInfo(pageIndex) {
        if (pageIndex >= 0 && pageIndex < this.pageInfos.length) {
            return this.pageInfos[pageIndex];
        }
        return null;
    }

    /**
     * ページが存在するかチェック
     */
    hasPages() {
        return this.pages.length > 0;
    }

    /**
     * 有効なページインデックスかチェック
     */
    isValidPageIndex(pageIndex) {
        return pageIndex >= 0 && pageIndex < this.pages.length;
    }

    /**
     * リセット
     */
    reset() {
        this.pages = [];
        this.pageInfos = [];
    }

    /**
     * 最後に追加されたページの内容を取得（重複チェック用）
     */
    getLastPageContent() {
        return this.pages.length > 0 ? this.pages[this.pages.length - 1] : null;
    }
}

    class LineCountDebug {
        title = '';
        constructor() {
            this.viewer = document.getElementById('viewer');
            this.book = document.getElementById('book');
            this.source = document.getElementById('source-content');

            this.topBar = document.getElementById('top-bar');
            this.topBarTitle = document.getElementById('top-bar-title');
            
            // DebugManagerとPageManagerインスタンス作成
            this.debugManager = new DebugManager();
            this.pageManager = new PageManager();
            
            // ページ制御管理
            this.currentPageIndex = 0;
            
            this.maxAllowedLines = 0;
            this.currentLineCount = 1;
            
            // 元のHTMLから段落データを抽出
            this.paragraphs = [];
            this.currentParagraphIndex = 0;
            this.currentParagraphContent = ''; // 現在の段落の内容のみ
            this.completedParagraphs = []; // 完了した段落のHTML
            this.totalLineCount = 1; // ページ全体での累積行数
            
            this.currentParagraphHasIndent = true; // ←追加
            
            this.init();
        }

        init() {
            // 元のHTMLから段落を抽出
            //this.extractParagraphs();
            
            // DOM要素のサイズが確定するまで少し待つ
            setTimeout(() => {
                this.setupMeasure();
                this.initEventListeners();
                this.debugManager.setupDebugUI();
                this.log('初期化完了');
            }, 100);
        }

        extractParagraphsFromPayLoad(payload) {
            this.paragraphs = [];
            const elements = Array.from(payload);
            let foundTitle = '';
            elements.forEach(element => {
                if (element.tagName === 'H2' || element.tagName === 'H3') {
                    // h2/h3のテキスト抽出を強化
                    let headingText = '';
                    // 1. textContent
                    if (element.textContent && element.textContent.trim() !== '') {
                        headingText = element.textContent.trim();
                    } else if (element.innerText && element.innerText.trim() !== '') {
                        // 2. innerText
                        headingText = element.innerText.trim();
                    } else if (element.innerHTML && element.innerHTML.replace(/<[^>]+>/g, '').trim() !== '') {
                        // 3. innerHTML (strip tags)
                        headingText = element.innerHTML.replace(/<[^>]+>/g, '').trim();
                    } else if (element.className && element.className.trim() !== '') {
                        // 4. className fallback
                        headingText = element.className;
                    } else {
                        // 5. default
                        headingText = 'タイトルなし';
                    }
                    // 既に全角化されている場合は再変換しない
                    // 半角英数字が含まれていればtoZenkaku
                    const zenkakuHeading = /[A-Za-z0-9]/.test(headingText) ? toZenkaku(headingText) : headingText;
                    this.paragraphs.push({
                        type: 'heading',
                        tag: element.tagName.toLowerCase(),
                        content: zenkakuHeading,
                        hasIndent: false
                    });
                    // 最初のh2をタイトルとして記憶
                    if (!foundTitle && element.tagName === 'H2' && zenkakuHeading) {
                        foundTitle = zenkakuHeading;
                    }
                } else if (element.tagName === 'P') {
                    // <p><br></p> のような空行を検出
                    const isEmptyLine =
                        (element.childNodes.length === 1 && element.childNodes[0].tagName === 'BR') ||
                        (element.innerHTML.trim() === '<br>' || element.innerHTML.trim() === '' || element.textContent.replace(/[\s\u3000]/g, '') === '');
                    
                    // id属性を取得
                    const paragraphId = element.getAttribute('id') || '';
                    
                    if (isEmptyLine) {
                        this.paragraphs.push({
                            type: 'paragraph',
                            tag: 'p',
                            content: '',
                            hasIndent: false, // 空行は字下げなし
                            isEmpty: true,
                            id: paragraphId
                        });
                    } else {
                        // 先頭の字下げ文字（全角・半角スペース・タブ等）を1文字削除
                        let text = element.textContent.replace(/^[ \u3000\t]/, "");
                        this.paragraphs.push({
                            type: 'paragraph',
                            tag: 'p',
                            content: toZenkaku(text),
                            hasIndent: true,
                            isEmpty: false,
                            id: paragraphId
                        });
                    }
                } else if (element.tagName === 'HR' && element.classList.contains('section-separator')) {
                    this.paragraphs.push({
                        type: 'separator',
                        tag: 'hr',
                        content: '',
                        hasIndent: false
                    });
                }
            });
            // タイトルセット
            this.title = foundTitle || '';
            if (this.topBarTitle) {
                this.topBarTitle.textContent = this.title || 'タイトル';
            }
            this.log(`段落抽出完了: ${this.paragraphs.length}個の段落`);
            this.paragraphs.forEach((para, i) => {
                const idInfo = para.id ? ` [ID: ${para.id}]` : '';
                this.log(`${i + 1}: ${para.type}${idInfo} \"${para.content ? para.content.substring(0, 20) : ''}...\"`);
            });
        }

        extractParagraphs() {
            this.extractParagraphsFromPayLoad(this.source.children);
        }

        setupMeasure() {
            try {
                const viewerStyle = window.getComputedStyle(this.viewer);
                const fontSize = parseFloat(viewerStyle.fontSize);
                const lineHeightValue = viewerStyle.lineHeight;
                const lineHeightPx = parseFloat(lineHeightValue);
                
                // サイズが0の場合はフォールバック値を使用
                const viewerWidth = this.viewer.clientWidth || 500;
                const viewerHeight = this.viewer.clientHeight || 400;
                const contentWidth = Math.max(viewerWidth - 40, 200); // 最低200px確保
                const contentHeight = Math.max(viewerHeight - 60, 200); // 最低200px確保
                
                // 横幅から最大行数を計算
                this.maxAllowedLines = Math.floor(contentWidth / lineHeightPx);
                
                this.debugManager.updateMaxLines(this.maxAllowedLines);
                this.debugManager.log(`計算値: maxLines=${this.maxAllowedLines}行`);
            } catch (error) {
                this.debugManager.log(`エラー: ${error.message}`);
            }
        }

        log(message) {
            this.debugManager.log(message);
        }

        displayCurrentContent(content) {
            this.book.innerHTML = `<div class='page visible'><div class="content">${content}</div></div>`;
        }

        addPage(content, startId = '', endId = '') {
            const wasAdded = this.pageManager.addPage(content, startId, endId);
            if (wasAdded) {
                this.debugManager.onPageAdded(this.pageManager.getPageCount(), this.pageManager.getPageCount(), startId, endId);
            }
            return wasAdded;
        }
        displayCurrentPage() {
            if (!this.pageManager.hasPages()) {
                this.debugManager.onNoPages();
                return;
            }

            const content = this.pageManager.getPageContent(this.currentPageIndex);
            const pageInfo = this.pageManager.getPageInfo(this.currentPageIndex);
            
            if (content) {
                this.book.innerHTML = `<div class='page visible'><div class="content">${content}</div></div>`;
                this.debugManager.onPageDisplayed(this.currentPageIndex + 1, this.pageManager.getPageCount(), pageInfo);
            }
        }

        nextPage() {
            if (this.currentPageIndex < this.pageManager.getPageCount() - 1) {
                this.currentPageIndex++;
                this.displayCurrentPage();
                this.log(`次ページ: ${this.currentPageIndex + 1}/${this.pageManager.getPageCount()}`);
            }
        }

        prevPage() {
            if (this.currentPageIndex > 0) {
                this.currentPageIndex--;
                this.displayCurrentPage();
                this.log(`前ページ: ${this.currentPageIndex + 1}/${this.pageManager.getPageCount()}`);
            }
        }

        setupSwipeEvents() {
            let startX = 0;
            let startY = 0;
            let isMouseDown = false;

            // タッチイベント
            this.viewer.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
            });

            this.viewer.addEventListener('touchend', (e) => {
                const endX = e.changedTouches[0].clientX;
                const endY = e.changedTouches[0].clientY;
                const deltaX = endX - startX;
                const deltaY = endY - startY;
                if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
                    if (deltaX > 0) {
                        this.prevPage();
                    } else {
                        this.nextPage();
                    }
                }
            });

            // マウスイベント
            this.viewer.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                startX = e.clientX;
                startY = e.clientY;
            });

            this.viewer.addEventListener('mouseup', (e) => {
                if (!isMouseDown) return;
                isMouseDown = false;
                const endX = e.clientX;
                const endY = e.clientY;
                const deltaX = endX - startX;
                const deltaY = endY - startY;
                if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
                    if (deltaX > 0) {
                        this.nextPage();
                    } else {
                        this.prevPage();
                    }
                }
            });
        }

        stepExecution() {
            this.log(`🔍 stepExecution開始: paragraphIndex=${this.currentParagraphIndex}, content="${this.currentParagraphContent}"`);

            let lineWidth = 28.8;
            let parentContentWidth = 0;
            if (this.book.querySelector('.page')) {
                parentContentWidth = this.book.querySelector('.page').scrollWidth;
            } else {
                parentContentWidth = this.viewer.clientWidth - 40; // 余白を引いた幅
            }

            // ページのID範囲を追跡 - 配列で全IDを管理
            let pageIds = [];

            while (true) {
                if (this.currentParagraphIndex >= this.paragraphs.length) {
                    // ★最後のページが未追加なら追加
                    const finalHTML = this.completedParagraphs.join('');
                    if (finalHTML) {
                        const startId = pageIds.length > 0 ? pageIds[0] : '';
                        const endId = pageIds.length > 0 ? pageIds[pageIds.length - 1] : '';
                        this.addPage(finalHTML, startId, endId);
                    }
                    this.log('全段落処理完了');
                    break;
                }

                const currentPara = this.paragraphs[this.currentParagraphIndex];

                // ページ開始時：段落にIDがあれば記録（現在のページがまだ空の場合のみ）
                if (this.completedParagraphs.length === 0 && currentPara.id && !pageIds.includes(currentPara.id)) {
                    pageIds.push(currentPara.id);
                    this.log(`🏷️ ページ開始ID記録: ${currentPara.id}`);
                }

                // ページまたぎ時のバッファ
                if (!this._paragraphBuffer) {
                    this._paragraphBuffer = currentPara.content.substring(this.currentParagraphContent.length);
                }

                // ページ先頭の字下げ制御
                if (this.currentParagraphContent === '') {
                    if (this.completedParagraphs.length === 0 && this.pageManager.getPageCount() > 0) {
                        this.currentParagraphHasIndent = false;
                    } else {
                        this.currentParagraphHasIndent = currentPara.hasIndent;
                    }
                }

                let lines = [];
                let pageFull = false;
                let startContentWidth = 0;

                // 空行や見出し・セパレータは一発で処理
                if (currentPara.type !== 'paragraph' || currentPara.isEmpty) {
                    // ページ先頭で空行の場合はスキップ（出力しない）
                    if (currentPara.isEmpty && this.completedParagraphs.length === 0) {
                        this.log('ページ先頭の空行をスキップ');
                        this.currentParagraphIndex++;
                        this.currentParagraphContent = '';
                        this._paragraphBuffer = null;
                        continue;
                    }
                    const finalHTML = this.generateHTML(
                        { ...currentPara, hasIndent: this.currentParagraphHasIndent },
                        this.currentParagraphContent
                    );
                    const finalAllHTML = this.completedParagraphs.join('') + finalHTML;
                    this.displayCurrentContent(finalAllHTML);
                    this.completedParagraphs.push(finalHTML);
                    
                    // IDを記録（重複チェック）
                    if (currentPara.id && !pageIds.includes(currentPara.id)) {
                        pageIds.push(currentPara.id);
                        this.log(`🏷️ ID記録: ${currentPara.id} (${currentPara.type})`);
                    }
                    
                    this.currentParagraphIndex++;
                    this.currentParagraphContent = '';
                    this._paragraphBuffer = null;
                    continue;
                }

                while (this._paragraphBuffer.length > 0 && !pageFull) {
                    let line = '';
                    let prevWidth = 0;

                    let startContentWidth = 0;
                    if (this.book.querySelector('.content')) {
                        startContentWidth = this.book.querySelector('.content').scrollWidth;
                    }
                    let lastContentWidth = 0;

                    // 1文字ずつ追加して改行判定
                    for (let i = 0; i < this._paragraphBuffer.length; i++) {
                        line += this._paragraphBuffer[i];

                        // 仮HTML生成
                        const currentHTML = this.generateHTML(
                            { ...currentPara, hasIndent: this.currentParagraphHasIndent },
                            this.currentParagraphContent + lines.join('') + line
                        );
                        const allHTML = this.completedParagraphs.join('') + currentHTML;
                        this.displayCurrentContent(allHTML);

                        lastContentWidth = this.book.querySelector('.content').scrollWidth;

                        // 改行検出
                        if (i > 0 && lastContentWidth > startContentWidth) {
                            // オーバーフロー文字をバッファに戻す
                            line = line.slice(0, -1);
                            this._paragraphBuffer = this._paragraphBuffer.slice(i);
                            lineWidth = lastContentWidth - startContentWidth;
                            break;
                        }

                        if (i === 0) startContentWidth = lastContentWidth;

                        // バッファを使い切った場合
                        if (i === this._paragraphBuffer.length - 1) {
                            this._paragraphBuffer = '';
                        }
                    }

                    if (line.length > 0) {
                        lines.push(line);
                    }

                    // ページ内容を仮生成して行数判定
                    const pageHTML = this.generateHTML(
                        { ...currentPara, hasIndent: this.currentParagraphHasIndent },
                        this.currentParagraphContent + lines.join('')
                    );
                    const allHTML = this.completedParagraphs.join('') + pageHTML;
                    this.displayCurrentContent(allHTML);

                    this.calculateCurrentLines();
                    if ((lastContentWidth + lineWidth * 2) >= parentContentWidth) {
                        pageFull = true;
                    }
                }

                // ページに追加した分だけcurrentParagraphContentを進める
                this.currentParagraphContent += lines.join('');

                // ページ内容を確定
                const finalHTML = this.generateHTML(
                    { ...currentPara, hasIndent: this.currentParagraphHasIndent },
                    this.currentParagraphContent
                );
                const finalAllHTML = this.completedParagraphs.join('') + finalHTML;
                this.displayCurrentContent(finalAllHTML);

                // 改ページ判定
                if (pageFull) {
                    this.log(`🚨 改ページ必要！ ${this.totalLineCount}行 >= ${this.maxAllowedLines}行`);
                    
                    // 現在の段落のIDを記録（まだ記録されていない場合）
                    if (currentPara.id && !pageIds.includes(currentPara.id)) {
                        pageIds.push(currentPara.id);
                        this.log(`🏷️ 改ページ前ID記録: ${currentPara.id}`);
                    }
                    
                    const startId = pageIds.length > 0 ? pageIds[0] : '';
                    const endId = pageIds.length > 0 ? pageIds[pageIds.length - 1] : '';
                    this.addPage(finalAllHTML, startId, endId);

                    // 次ページの準備
                    this.completedParagraphs = [];
                    this.totalLineCount = 1;
                    this.currentParagraphHasIndent = false; // ★分断パラグラフは字下げなし
                    
                    // 次ページのID配列をリセット
                    pageIds = [];
                    // 分断された段落の場合は同じIDから始まる
                    if (this._paragraphBuffer && this._paragraphBuffer.length > 0 && currentPara.id) {
                        pageIds.push(currentPara.id);
                        this.log(`🏷️ 次ページ継続ID: ${currentPara.id}`);
                    }

                    // currentParagraphContentは進めた状態で
                    // _paragraphBufferは残りを保持
                    // ただし、段落が分断されていない場合はcurrentParagraphContentをリセットし、次ページで重複しないようにする
                    if (!this._paragraphBuffer || this._paragraphBuffer.length === 0) {
                        // 段落が分断されていない（全部収まった）場合は次ページで重複しないように進める
                        this.currentParagraphIndex++;
                        this.currentParagraphContent = '';
                        this._paragraphBuffer = null;
                    } else {
                        // 分断された場合はcurrentParagraphContentのみリセット
                        this.currentParagraphContent = '';
                    }
                    this.log(`🔄 改ページ完了: バッファ残り="${this._paragraphBuffer}"`);
                    continue; // ←再帰の代わりにループ継続
                }

                // 段落終了
                if (!this._paragraphBuffer || this._paragraphBuffer.length === 0) {
                    this.completedParagraphs.push(finalHTML);
                    this.log(`段落${this.currentParagraphIndex + 1}完了: ${finalHTML}`);

                    // IDを記録（重複チェック）
                    if (currentPara.id && !pageIds.includes(currentPara.id)) {
                        pageIds.push(currentPara.id);
                        this.log(`🏷️ 段落完了ID記録: ${currentPara.id}`);
                    }

                    this.currentParagraphIndex++;
                    this.currentParagraphContent = '';
                    this._paragraphBuffer = null;
                    this.log(`🔍 段落完了でリセット: paragraphIndex=${this.currentParagraphIndex}, content="${this.currentParagraphContent}"`);
                    continue; // ←再帰の代わりにループ継続
                }

                // 1行進めたので終了（次のstepで残りを処理）
                break;
            }
        }

        calculateCurrentLines() {
            const pageElement = this.book.querySelector('.content');
            if (!pageElement) {
                this.totalLineCount = 1;
                return;
            }

            const allTextNodes = [];
            
            function collectTextNodes(node) {
                if (node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== '') {
                    allTextNodes.push(node);
                } else {
                    for (let child of node.childNodes) {
                        collectTextNodes(child);
                    }
                }
            }
            collectTextNodes(pageElement);
            
            if (allTextNodes.length > 0) {
                const range = document.createRange();
                range.setStart(allTextNodes[0], 0);
                range.setEnd(allTextNodes[allTextNodes.length - 1], allTextNodes[allTextNodes.length - 1].textContent.length);
                const rangeRect = range.getBoundingClientRect();
                const rangeWidth = rangeRect.width;
                this.totalLineCount = Math.ceil(rangeWidth / 28.8);
                
                this.log(`行数計算: 幅=${rangeWidth.toFixed(2)}px, 行数=${this.totalLineCount}行`);
            } else {
                this.totalLineCount = 1;
            }
            
            this.debugManager.updateCurrentLines(this.totalLineCount);
        }

        generateHTML(paragraph, content) {
            if (paragraph.type === 'heading') {
                // headingはparagraph.contentを常に使う（currentParagraphContentは使わない）
                const headingText = (!paragraph.content || paragraph.content.trim() === "") ? "&nbsp;" : paragraph.content;
                return `<${paragraph.tag}><span>${headingText}</span></${paragraph.tag}>`;
            } else if (paragraph.type === 'separator') {
                return `<hr class="section-separator">`;
            } else if (paragraph.isEmpty) {
                // 空行は <p class="empty-line"><br></p> で出力
                return `<p class="empty-line"><br></p>`;
            } else {
                const className = paragraph.hasIndent ? '' : 'no-indent-p';
                return `<p class="${className}">${content}</p>`;
            }
        }

        // 3. ページ再生成用メソッド
        regeneratePages() {
            this.resetPagesAndState();
            this.setupMeasure();
            this.stepExecution();
        }

        // reset()も共通リセットを利用
        reset() {
            this.resetPagesAndState();
            this.debugManager.clearLog();
            this.log('リセット完了');
            this.setupMeasure();
            this.displayCurrentPage();
        }

        resetPagesAndState() {
            this.currentParagraphIndex = 0;
            this.currentParagraphContent = '';
            this.completedParagraphs = [];
            this.totalLineCount = 1;
            this.pageManager.reset();
            this.currentPageIndex = 0;
            this.book.innerHTML = '';
            this._paragraphBuffer = null;
            this.currentParagraphHasIndent = true;
        }

        initEventListeners() {
            document.getElementById('step-btn').addEventListener('click', () => {
                this.stepExecution();
                this.displayCurrentPage();
            });

            document.getElementById('reset-btn').addEventListener('click', () => {
                this.reset();
            });

            document.getElementById('copy-log-btn').addEventListener('click', () => {
                this.debugManager.copyLog();
            });

            document.getElementById('prev-page-btn').addEventListener('click', () => {
                this.prevPage();
            });

            document.getElementById('next-page-btn').addEventListener('click', () => {
                this.nextPage();
            });

            // スワイプイベントも初期化時に設定
            this.setupSwipeEvents();

            // ↓ここから追加
            const viewer = this.viewer;
            const bottomBar = document.getElementById('bottom-bar');
            const topBar = this.topBar;
            let barVisible = false;

            // 中央付近タップで上下バー表示/非表示
            viewer.addEventListener('click', (e) => {
                const rect = viewer.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                // 中央30%エリア
                if (
                    x > rect.width * 0.35 && x < rect.width * 0.65 &&
                    y > rect.height * 0.35 && y < rect.height * 0.65
                ) {
                    barVisible = !barVisible;
                    bottomBar.classList.toggle('hidden', !barVisible);
                    topBar.classList.toggle('hidden', !barVisible);
                }
            });
            // ハンバーガーメニュークリック（今はダミー）
            document.getElementById('topbar-menu').addEventListener('click', () => {
                this.log('ハンバーガーメニュークリック');
                // 必要ならここでメニュー表示
            });
            // ブラウザアイコンクリック（今はダミー）
            document.getElementById('topbar-browser').addEventListener('click', () => {
                this.log('ブラウザアイコンクリック');
                // 必要ならここで外部リンク等
            });

            // 文字サイズ変更
            document.getElementById('font-bigger').addEventListener('click', () => {
                this.changeFontSize(1);
            });
            document.getElementById('font-smaller').addEventListener('click', () => {
                this.changeFontSize(-1);
            });

            // ナイトモード切替（色は後で指定）
            document.getElementById('toggle-night').addEventListener('click', () => {
                document.body.classList.toggle('night-mode');
            });

            document.getElementById('loadHtmlBtn').addEventListener('click', async () => {
                const fileInput = document.getElementById('fileInput');
                const file = fileInput.files[0];
                if (!file) {
                    this.log('ファイルを選択してください');
                    return;
                }
                const text = await file.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(text, "text/html");
                const title = doc.querySelectorAll('h1.p-novel__title.p-novel__title--rensai');
                // クラスが両方一致するdivを取得
                const targets = doc.querySelectorAll('div.js-novel-text.p-novel__text');
                this.log('div.js-novel-text.p-novel__text タグを取得しました: ' + targets.length + '件');
                if (targets) {
                    // その直下の要素をsource-contentにセット
                    this.source.innerHTML = '';

                    // タイトル取得時も全角化
                    if (title.length > 0) {
                        title.forEach(t => {
                            this.log('タイトルを取得しました: ' + toZenkaku(t.textContent));
                            const titleElement = document.createElement('h2');
                            titleElement.className = t.className;
                            titleElement.textContent = toZenkaku(t.textContent);
                            this.source.appendChild(titleElement);
                        });
                    }

                    targets.forEach((target, idx) => {
                        // 直下の子要素をsource-contentに追加
                        Array.from(target.children).forEach(el => {
                            this.source.appendChild(el.cloneNode(true));
                        });
                        // セクションセパレータを挿入（最後のセクション以外）
                        if (idx < targets.length - 1) {
                            const hr = document.createElement('hr');
                            hr.className = 'section-separator';
                            this.source.appendChild(hr);
                        }
                    });
                    this.extractParagraphs();
                    this.regeneratePages();
                    this.currentPageIndex = 0;
                    this.displayCurrentPage();
                    this.log('外部HTML読込成功: div.js-novel-text.p-novel__text の直下要素を読み込みました');
                } else {
                    this.log('指定タグ(div.js-novel-text.p-novel__text)が見つかりません');
                }
            });
        }

        loadEpisodeFromFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const content = e.target.result;
                this.source.innerHTML = content;
                this.extractParagraphs();
                this.reset();
                this.log('エピソード読み込み完了');
            };
            reader.onerror = (e) => {
                this.log('ファイル読み込みエラー: ' + e.target.error.message);
            };
            reader.readAsText(file);
        }

        // 文字サイズ変更用メソッド
        changeFontSize(delta) {
            const viewer = this.viewer;
            const style = window.getComputedStyle(viewer);
            let fontSize = parseFloat(style.fontSize) || 16;
            fontSize = Math.max(10, Math.min(36, fontSize + delta));
            viewer.style.fontSize = fontSize + 'px';
            this.log(`文字サイズ: ${fontSize}px`);

            // ページ再生成
            this.regeneratePages();
            this.displayCurrentPage();
        }
    }

    // ページ読み込み完了後にLineCountDebugを初期化
    window.addEventListener('load', () => { 
        new LineCountDebug(); 
    });
    </script>
</body>
</html>